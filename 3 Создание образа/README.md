# Создание образа
DOCKERFILE - это обычный текстовый файл, где мы при помощи инструкций (FROM, CMD и т.д.) описываем каким должен быть наш образ, то есть расширяем его функционал. Каждая инструкция создает слой.
## Пример DOCKERFILE
```
# Указываем образ для контейнера
FROM node:17 

# Копируем файл в директорию app
COPY ./script.js /app/script.js

# Запускаем скрипт при поднятии контейнера
CMD ["node", "/app/script.js"]
```

## Несколько BEST PRACTICES
1. Использовать ```.dockerignore``` файл (ex. игнорируем файлы с секретными данными). Нельзя токены, пароли класть в образы.
2. Устанавливать только то, что действительно нужно
3. Стараться уменьшить количество слоев

### Пример 6 слоев в один
Так делать не надо:
```
RUN apt-get update 
RUN apt-get install -y vim
RUN apt-get install -y python3
RUN apt-get install -y python3-pip
RUN apt-get install -y curl
RUN apt-get install -y git
```

А так надо (обновляем и устанавливаем в одном слое):
```
RUN apt-get update && apt-get install -y \
vim \
python3 \
python3-pip \
curl \
git
```

## Сделаем свой образ кастомной убунты
1. Создадим ```Dockerfile```
2. Указываем базовый образ
```
FROM ubuntu:20.04
```
3. Указываем рабочую директорию
```
WORKDIR /home/igor
```
4. Собираем наш образ командой ```docker build```:
Опция ```-t``` означает, что мы задаем имя и тэг нашего образа.
А затем указываем папку, в которой находится Dockerfile. Можно поставить точку ``` .```, что соотвествует текущей папке.
Также можно добавить опцию ```-f``` и указать точное название Dockerfile (если его название отличается от Dockerfile)
```
docker build -t custom_ubuntu:1 .
```
5. А теперь посмотрим список образов и увидим наш образ
```
docker images
```
6. Расширим Dockerfile, добавив файлы к образу инструкцией (ADD или COPY)
```
COPY <ПУТЬ К ФАЙЛУ НА НАШЕМ ПК> <ПУТЬ К ФАЙЛУ В КОНТЕЙНЕРЕ>
COPY random_file.txt random_file.sh
```

Этот файл будет лежать в /home/igor/random_file.sh, так как до этого указали WORKDIR

7. Соберем образ с тэгом 2
```
docker build -t custom_ubuntu:2 .
```

8. Установим nano, wget и curl при помощи инструкции RUN
```
RUN apt-get update && apt-get install -y nano wget curl git
```
Очевидно, что пункт 8 никогда не будет меняться, так как все ПО будет присутсвовать во всех сборках (очень нужное ПО), поэтому лучше его поднять выше до определения директорий, чтобы эта инструкция закешировалась. 

ВАЖНО! Вверх нужно поднимать те инструкции, которые точно не будут изменены.

## .dockerignore
Создадим в папке с dockerfile папку huge_dir и положим в нее тяжелый файл, который не будет использоваться в dockerfile. Но несмотря на то, что он явно не указан в dockerfile при сборке образа демон все равно подгрузит его (потратив ресурсы и время просто так). Чтобы избежать этого, создадим в папке файл .dockerignore и впишем в него название папки. Попробуем собрать образ снова и увидим, что теперь демон игнорирует эту папку при сборке образа. 


## CMD и ENTRYPOINT
9. Изменим интерфейс нашего терминала в контейнере, добавив в dockerfile следующее:
```
# Изменим интерфейс терминала в контейнере
RUN sh -c "$(wget -0- hhtps://github.com/deluan/zsh-in-docker/releases/download/v1.1.1/zsh-in-docker.sh)" -- \
    -t robbyrussel \
    -p https://github.com/zsh-users/zsh-autosuggestions

ENV ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE="fg=#dedede,bg=#9c9c9c,bold,underline"
```

Теперь соберем образ и запустим контейнер. Увидим, что интерфейс не изменился, введем для этого ```zsh``` внутри контейнера, чтобы изменить его. 

```
docker build -t custom_ubuntu:4 . 
docker run -it --rm custom_ubuntu:4
```

Как сделать, чтобы не приходилось постоянно писать ```zsh```? Нужно использовать ```CMD``` или ```ENTRYPOINT``` в dockerfile. Эти инструкции имеют следующий синтаксис:

```
ENTRYPOINT zsh
#или 
ENTRYPOINT ["zsh"]

# Аналогично CMD
CMD zsh
#или 
CMD ["zsh"]
```
Создадим два разных образа ```CMD``` и ```ENTRYPOINT```: 
```
docker build  custom_ubuntu/cmd . 
docker build  custom_ubuntu/entry .
```
В чем разница между ```CMD``` и ```ENTRYPOINT```? Представим, что у нас в образе будет лежать некоторый скрипт script.sh. И у нас есть задача, запустить контейнер с оболочкой zsh и выполнить этот скрипт. Тогда синтаксис запуска будет следующий:

Для ENTRYPOINT:
```
docker run -it --rm custom_ubuntu/entry script.sh
```

ДЛЯ CMD:
Этот запуск упадет с ошибкой, так как script.sh перезапишет CMD.
```
docker run -it --rm custom_ubuntu/cmd script.sh
```
Правильно запустить CMD будет так (указав zsh в аргументах cmd):
```
docker run -it --rm custom_ubuntu/cmd zsh script.sh
```

## Интерактивный режим и аргументы
# Добавим скрипт приветсвтвия и запутим его
```
RUN touch hello.sh && echo "echo 'Hello from container'" > hello.sh
CMD [ "hello.sh" ]
```

```
docker build -t custom_ubuntu:latest .
# Запустим без интерактивного режима и увидим приветствие, после которого контейнер остановится - все ок.
docker run --rm custom_ubuntu:latest
# Запустим в интерактивном режиме и увидим приветствие, после которого контейнер остановится - не ок, в чем дело?
docker run -it --rm custom_ubuntu:latest
```

Интерактивный режим значит то, что мы оставляем стандартный поток ввода открытым. А наш скрипт не слушает поток ввода, в отличие от ноды (см. node на dockerhub, нода там запускается также через CMD, но она слушает поток ввода).

Пример. Можем запустить ноду в интерактивном режиме: 
```
docker run -it --rm node
```
А можем переопределить CMD и зайти в контейнер в котором есть нода
```
docker run -it --rm node bash
```

Но есть нюанс: в терминале ```bash bash``` или ```bash ls``` не будут работать, нужно при помощи аргумента ```-c``` указать явно, что это команда и инструкция выполнится:
```
bash -c bash
bash -c ls
```

Тогда с учетом этого команда для запуска контейнера с hello.sh будет следующая (чтобы получить интерактивный режим):
```
docker run -it --rm custom_ubuntu:latest -c 'zsh'
```

А можно указать точку входа без аргумента:
```
docker run -it --rm --entrypoint=zsh custom_ubuntu:latest
```

## Разница между ADD и COPY
Рассмотрим разницу в использовании на двух примерах — добавление архива и файла по ссылке. 

Dockerfile для ADD:
```
FROM ubuntu:22.04

WORKDIR /zip
ADD archive.tar.xz .

WORKDIR /url
ADD https://airflow.apache.org/docs/apache-airflow/2.4.0/docker-compose.yaml .
```

Соберем образ. При использовании ADD архив распаковался, а файл (в данном случае docker-compose.yaml) по ссылке скачался.

Теперь тоже самое с COPY
```
FROM ubuntu:22.04

WORKDIR /zip
COPY archive.tar.xz .

WORKDIR /url
COPY https://airflow.apache.org/docs/apache-airflow/2.4.0/docker-compose.yaml .
```
При использовании COPY файл по ссылке скачивать нельзя, поэтому упали с ошибкой. При этом архив не распаковался.

# Собственные образы на Docker Hub
## Регистрация на Docker Hub
1. Для начала заходим на сам сайт Docker Hub (https://hub.docker.com/).
2. Нажимаем кнопку Register.
3. Там нужно ввести 3 значения — Docker ID, Email и Password.
* Docker ID — можно назвать логином. Он будет составлять часть названия образа (см.ниже)
4. Нажимаете галочки, затем Sign Up.
5. На почту придет уведомление. Нужно подтвердить ваш адрес.
6. Заходите на Docker Hub под созданным пользователем.
## Создание своего репозитория
После того, как вы зарегистрировались, необходимо создать репозиторий (прямо как на GitHub).

На странице вы увидите плашку Create a Repository. Нажмите на неё.  

После нажатия вы попадете на страницу создания репозитория. Создайте там свой репозиторий.

Отлично! Теперь у вас есть свой репозиторий, где можно хранить свои образы. 

## Команды для работы с репозиторием
После того, как у вас появился репозиторий, попробуйте загрузить в него свой образ. 

Чтобы это сделать, необходимо локально авторизоваться, при необходимости сменить имя и тег образа и сделать пуш на Docker Hub.  

1. Для локальной авторизации используется команда ```docker login```. 
В таком случае у вас попросит username (как раз Docker ID) и пароль.
2. Чтобы сменить название образа и тег, нужно воспользоваться командой
```docker tag <исходный_образ> <результирующий_образ>```. 
В названии результирующего образа будет присутствовать ваш username, слеш (/), название репозитория.
3. Чтобы отправить образ на Docker Hub, нужно ввести команду ```docker push <образ>```
Чтобы локально разлогиниться, нужно ввести команду ```docker logout```.

После того, как вы загрузили образ на Docker Hub, вы можете его скачать. 

Делается это командой ```docker pull```

## ИТОГ
FROM — задаем базовый образ, на основе которого собираем новый 

COPY — копируем файл с нашей файловой системы в файловую систему контейнеров 

ADD — добавляем файл или ссылку с нашей файловой системы в образ 

RUN — выполняем команду 

WORKDIR — устанавливаем рабочую директорию 

ENTRYPOINT — задаем точку входа для запуска контейнера 

CMD — задаем точку входа для запуска контейнера 




